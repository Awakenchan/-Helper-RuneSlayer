local Rune = {}
local NotificationLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/IceMinisterq/Notification-Library/Main/Library.lua"))()
local UserInputService = game:GetService("UserInputService")
local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local LogService = game:GetService("LogService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local ClientModules = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("ClientModules")
local Mouse = LocalPlayer:GetMouse()
local BoolValues = Character:WaitForChild("BoolValues")
local Map = workspace:WaitForChild("Map")

local Modules = {
    EquipHandler = require(ReplicatedStorage.Modules.EquipHandler),
    MaterialSounds = require(ReplicatedStorage.Modules.MaterialSounds),
    RayCastModule = require(ReplicatedStorage.Modules.RayCast),
    DropSystem = require(ReplicatedStorage.Modules.DropSystem),
    StunHandler = require(ReplicatedStorage.Modules.StunHandler),
    FootStepModule = require(ReplicatedStorage.Modules.FootStepModule),
    Indicators = require(ReplicatedStorage.Modules.Indicators),
    Runes = require(ReplicatedStorage.Modules.Runes),
    GearStats = require(ReplicatedStorage.Modules.GearStats),
    MovementModule = require(ReplicatedStorage.Modules.MovementModule),
    MoneyModule = require(ReplicatedStorage.Modules.MoneyModule),
    ConfigModule = require(ReplicatedStorage.Modules.ConfigModule),
    EffectModule = require(ReplicatedStorage.Modules.EffectModule),
    NPCStages = require(ReplicatedStorage.Modules.NPCStages),
    ToolFrameSetUp = require(ReplicatedStorage.Modules.ToolFrameSetUp),
    ConfirmationModule = require(ReplicatedStorage.Modules.ConfirmationModule),
    ReputationModule = require(ReplicatedStorage.Modules.ReputationModule),
    InfoOverlay = require(ReplicatedStorage.Modules.InfoOverlays),
    GuildModule = require(ReplicatedStorage.Modules.GuildModule),
    TradingModule = require(ReplicatedStorage.Modules.TradingModule),
    Network = require(ReplicatedStorage.Modules.Network),
    CharUtilities = require(ClientModules.CharUtilities)
}

getgenv().MobList = {}
Rune.InventoryCache = {}
Rune.FoundItems = {}  
Rune.Loops = {}

function Rune.LoopStart(name, func, interval)
    assert(typeof(name) == "string", "Loop name must be a string")
    assert(typeof(func) == "function", "Loop function must be a function")
    assert(typeof(interval) == "number", "Interval must be a number")
    if Rune.Loops[name] then
        warn("Loop '" .. name .. "' is already running.")
        return
    end
    Rune.Loops[name] = true
    task.spawn(function()
        while Rune.Loops[name] do task.wait(interval)
            func()
        end
    end)
end
function Rune.LoopStop(name)
    assert(typeof(name) == "string", "Loop name must be a string")
    if not Rune.Loops[name] then
        warn("Loop '" .. name .. "' is not running.")
        return
    end
    Rune.Loops[name] = nil
end
function Rune.CreateMobList()
    local seen = {}
    local excludedInstances = {} 
    local petNames = {}
    for _, player in pairs(Players:GetPlayers()) do
        local playerFolder = workspace.Alive:FindFirstChild(player.Name)
        if playerFolder then
            local pet = playerFolder:FindFirstChild("Pet")
            if pet and pet:IsA("ObjectValue") and pet.Value then
                petNames[pet.Value.Name] = true 
            end
        end
    end
    for _, mob in pairs(workspace.Alive:GetChildren()) do
        if Players:GetPlayerFromCharacter(mob) then continue end

        local fullName = mob.Name 
        local baseName = fullName:match("^(.-)%..*$") or fullName 

        if petNames[fullName] then
            excludedInstances[fullName] = true 
        else
            if not seen[baseName] and not excludedInstances[fullName] then
                warn(baseName)
                seen[baseName] = true 
                table.insert(getgenv().MobList, baseName)
            end
        end
    end
    warn("CreatedMobList")
end

function Rune.GetCharacterComponents()
    local character = LocalPlayer.Character
    if not character or not character.Parent then return nil end
    
    local components = {
        character = character,
        characterHandler = character:FindFirstChild("CharacterHandler"),
        input = character:FindFirstChild("CharacterHandler") and character.CharacterHandler:FindFirstChild("Input"),
        events = character:FindFirstChild("CharacterHandler") and character.CharacterHandler:FindFirstChild("Input") and character.CharacterHandler.Input:FindFirstChild("Events")
    }
    
    for name, component in pairs(components) do
        if not component then
            return nil
        end
    end
    
    return components
end

function Rune.GetPlayerGui()
    local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
    if not playerGui then return nil end
    
    return playerGui
end

function Rune.MouseEvent(event)
    assert(typeof(event) == "string", "Event must be a string")
    
    local components = Rune.GetCharacterComponents()
    if not components then return end
    
    local mouseInput = components.events:FindFirstChild("MouseInput")
    if not mouseInput then return end
    
    mouseInput:Fire({ Config = event })
end

function Rune.MouseInput(event)
    assert(typeof(event) == "string", "Event must be a string")
    
    local components = Rune.GetCharacterComponents()
    if not components then return end
    
    if Modules.Network then
        Modules.Network.connect("MouseInput", "Fire", components.character, { Config = event })
    end
end

function Rune.MasterSignal(event)
    assert(typeof(event) == "string", "Event must be a string")
    
    local components = Rune.GetCharacterComponents()
    if not components then return end
    
    if Modules.Network then
        Modules.Network.connect("MasterEvent", "FireServer", components.character, { Config = event })
    end
end

function Rune.Interact(Object, Action)
    assert(typeof(Object) == "Instance", "Object must be an Instance")
    assert(typeof(Action) == "string", "Action must be a string")
    
    local components = Rune.GetCharacterComponents()
    if not components then return end
    
    local interact = components.events:FindFirstChild("Interact")
    if not interact then return end
    
    interact:FireServer({
        player = LocalPlayer,
        Object = Object,
        Action = Action
    })
end

function Rune.Smelt(Amount, Item, Into)
    assert(typeof(Amount) == "number", "Amount must be a number")
    assert(typeof(Item) == "string", "Item must be a string")
    assert(typeof(Into) == "string", "Into must be a string")
    
    local playerGui = Rune.GetPlayerGui()
    if not playerGui then return end
    
    local craftingGui = playerGui:FindFirstChild("CraftingGui")
    if not craftingGui then return end
    
    local localScript = craftingGui:FindFirstChild("LocalScript")
    if not localScript then return end
    
    local remoteEvent = localScript:FindFirstChild("RemoteEvent")
    if not remoteEvent then return end
    
    remoteEvent:FireServer({
        AmountToCraft = Amount,
        SelectedItem = {
            Materials = {{ Name = Item, Amount = Amount }},
            ToolTip = "",
            Station = "Smelter",
            Name = Into
        }
    })
end
function Rune.NearestInteract()
    local event = Instance.new("BindableEvent")  
    local textLabel: TextLabel? = LocalPlayer.PlayerGui:FindFirstChild("GUI") and LocalPlayer.PlayerGui.GUI:FindFirstChild("Interact") and LocalPlayer.PlayerGui.GUI.Interact:FindFirstChild("TextLabel")
    if not textLabel or not textLabel:IsA("TextLabel") then return end
    local action: string? = textLabel.Text:match("%[E%] %- (%S+)")
    local root: BasePart? = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not action or not root then return end
    local nearest: Instance?, minDist: number = nil, 10
    for _, parent in ipairs({workspace:FindFirstChild("Harvestable"), workspace:FindFirstChild("Effects") and workspace.Effects:FindFirstChild("NPCS")}) do
        if parent then
            for _, obj in ipairs(parent:GetChildren()) do
                if (obj:IsA("Model") or obj:IsA("MeshPart") or obj:IsA("UnionOperation")) and not obj:IsDescendantOf(LocalPlayer.Character) then
                    local part: BasePart? = obj:IsA("Model") and obj.PrimaryPart or obj
                    local dist: number? = part and (root.Position - part.Position).Magnitude
                    if dist and dist < minDist then
                        nearest, minDist = obj, dist
                    end
                end
            end
        end
    end
    if nearest then
        if action == "Talk" then action = "NPC" end
        Rune.Interact(nearest, action)
        warn("Interacting with:", nearest:GetFullName(), "Action:", action)
          task.spawn(function()
            while nearest.Parent do 
                task.wait() 
            end
            warn("Item Done With:", nearest.Name)
            event:Fire(true) 
        end)
    end
    return event.Event
end

function Rune.Parry()
    task.spawn(function()
        local success = pcall(function()
            Rune.MasterSignal("Block")
            task.wait()
            Rune.MasterSignal("StopBlock")
        end)
        if not success then
            warn("Parry failed - character may be dead or components missing")
        end
    end)
end

function Rune.getNearestMob(maxDistance)
    local aliveFolder = workspace:FindFirstChild("Alive")
    if not aliveFolder then
        warn("Alive folder not found in workspace")
        return nil
    end
    
    local player = game.Players.LocalPlayer
    local playerPosition = player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.Position or Vector3.new(0, 0, 0)
    local nearestMob = nil
    local nearestDistance = maxDistance or 400
    
    for _, mob in ipairs(aliveFolder:GetChildren()) do
        if mob:IsA("Model") and mob.Name ~= player.Name then
            local primaryPart = mob.PrimaryPart or mob:FindFirstChild("HumanoidRootPart")
            if primaryPart then
                local distance = (primaryPart.Position - playerPosition).Magnitude
                if distance <= nearestDistance then
                    nearestMob = mob
                    nearestDistance = distance
                end
            end
        end
    end
    
    return nearestMob
end

function Rune.TweenTo(speed, cf)
    tweenService, tweenInfo = game:GetService("TweenService"), TweenInfo.new(speed, Enum.EasingStyle.Linear)    
    local event = Instance.new("BindableEvent")  
    local player = game:GetService("Players").LocalPlayer
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        event:Fire(false)  
        return event.Event
    end
    local hrp = character.HumanoidRootPart
    local tween = tweenService:Create(hrp, tweenInfo, {CFrame = CFrame.new(cf)}) 
    tween:Play()
    task.spawn(function()
        while tween.PlaybackState == Enum.PlaybackState.Playing do  
            task.wait(0.1) 
            if (hrp.Position - cf).Magnitude <= 5 then
                tween:Cancel()
                event:Fire(true) 
                break
            end
        end
    end)

    return event.Event  
end

function Rune.IsValidHarvest(Item)
    assert(typeof(Item) == "Instance", "Object must be an Instance")
    
    local validClasses = { UnionOperation = true, MeshPart = true, Model = true }
    local itemType = Item.ClassName
    if validClasses[itemType] then
        return true, itemType
    end
    return false, nil 
end

function Rune.LookUpinHarvest(ItemName, radius, originPosition)
    assert(typeof(ItemName) == "string", "ItemName must be a string")
    assert(typeof(radius) == "number", "Radius must be a number")
    assert(typeof(originPosition) == "Vector3", "Expected Vector3 position")
    local nearestItem = nil
    local shortestDistance = radius
    local positionstanding = nil
    local itemPosition;
    for _, item in pairs(workspace.Harvestable:GetChildren()) do
        local isValid, dataType = Rune.IsValidHarvest(item)
        if isValid and item.Name == ItemName then
            if dataType == "Model" then
                itemPosition = item.PrimaryPart and item.PrimaryPart.Position or nil
            else
                itemPosition = item.Position
            end
            if itemPosition then
                local distance = (originPosition - itemPosition).Magnitude
                if distance < shortestDistance then
                    shortestDistance = distance
                    nearestItem = item
                    positionstanding = itemPosition
                end
            end
        end
    end

    return nearestItem,positionstanding
end

function Rune.ServerHop()
    local HttpService = game:GetService("HttpService")
    local TeleportService = game:GetService("TeleportService")
    
    local servers = {}
    local req = request({
        Url = string.format("https://games.roblox.com/v1/games/%s/servers/Public?sortOrder=Asc&limit=100", game.PlaceId)
    })
    local body = HttpService:JSONDecode(req.Body)
    
    if body and body.data then
        for _, server in pairs(body.data) do
            if server.playing and server.playing < server.maxPlayers then
                table.insert(servers, server)
            end
        end
        
        if #servers > 0 then
            table.sort(servers, function(a, b)
                return a.playing < b.playing
            end)
            TeleportService:TeleportToPlaceInstance(game.PlaceId, servers[1].id)
        end
    end
end

function Rune.PlaySound(id)
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local sound = Instance.new("Sound")
    sound.SoundId = id
    sound.Volume = 1
    sound.Parent = character:FindFirstChild("HumanoidRootPart") 
    sound:Play()
end
function Rune.RefreshInventory()
    local backpack = game:GetService("Players").LocalPlayer.Backpack
    if  #Rune.InventoryCache > 0 then
        Rune.InventoryCache = {}
    end 
    for _, item in ipairs(backpack:GetChildren()) do
        Rune.InventoryCache[item.Name] = Rune.InventoryCache[item.Name] or {}
        table.insert(Rune.InventoryCache[item.Name], item)
    end
end
function Rune.WatchInventory()
    local backpack = game:GetService("Players").LocalPlayer.Backpack
    backpack.ChildAdded:Connect(function(item)
        Rune.InventoryCache[item.Name] = Rune.InventoryCache[item.Name] or {}
        table.insert(Rune.InventoryCache[item.Name], item)
    end)
    backpack.ChildRemoved:Connect(function(item)
        if Rune.InventoryCache[item.Name] then
            for i, cachedItem in ipairs(Rune.InventoryCache[item.Name]) do
                if cachedItem == item then
                    table.remove(Rune.InventoryCache[item.Name], i)
                    break
                end
            end

            if #Rune.InventoryCache[item.Name] == 0 then
                Rune.InventoryCache[item.Name] = nil
            end
        end
    end)
end

function Rune.LookUpInventory(searchTerm, partialMatch)
    assert(typeof(searchTerm) == "string", "Search term must be a string")
    assert(partialMatch == nil or typeof(partialMatch) == "boolean", "partialMatch must be a boolean or nil")
    local foundItems = {}
    for itemName, items in pairs(Rune.InventoryCache) do
        if (partialMatch and string.find(itemName, searchTerm)) or (not partialMatch and itemName == searchTerm) then
            for _, item in ipairs(items) do
                table.insert(foundItems, item)
            end
        end
    end
    Rune.FoundItems = foundItems  
    return #foundItems > 0, foundItems
end

function Rune.SellEvent(state)
    assert(typeof(state) == "boolean", "State must be a boolean")
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local charHandler = assert(character:FindFirstChild("CharacterHandler"), "CharacterHandler not found")
    local charInput = assert(charHandler:FindFirstChild("Input"), "Input not found")
    local events = assert(charInput:FindFirstChild("Events"), "Events not found")
    local remoteEvent = assert(events:FindFirstChild("SellEvent"), "SellEvent not found")
    remoteEvent:FireServer(state)
end

function Rune.SellItem(itemName)
    assert(typeof(itemName) == "string", "Item name must be a string")
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local backpack = player.Backpack
    local charHandler = assert(character:FindFirstChild("CharacterHandler"), "CharacterHandler not found")
    local charInput = assert(charHandler:FindFirstChild("Input"), "Input not found")
    local events = assert(charInput:FindFirstChild("Events"), "Events not found")
    local remoteEvent = assert(events:FindFirstChild("SellEvent"), "SellEvent not found")
    local found, item = Rune.LookUpInventory(itemName)
    if not found then
        return warn("Item '" .. itemName .. "' not found in Backpack")
    end
    local args = {
        [1] = item
    }
    remoteEvent:FireServer(unpack(item))
end

getgenv().moblistt = {}
function Rune.MobNotifier(lf,ifnot)
    local count = 0
    local aliveFolder = workspace:FindFirstChild("Alive")
    local dontexist = nil
    if not aliveFolder then
        warn("Alive folder not found in workspace")
        return
    end
    if count == 0 then
        aliveFolder.ChildAdded:Connect(function(newMob)
            local fullName2 = newMob.Name 
            local baseName2 = fullName2:match("^(.-)%..*$") or fullName2 
            if pcall(table.find(lf,baseName2) or table.find(getgenv().moblistt,baseName2) or table.find(functions.mobFarm.selectedMobs,baseName2) and getgenv().mobalert) then
                Rune.PlaySound("rbxassetid://85243953582838")
                NotificationLibrary:SendNotification("Success", "[Mob Notifier]: mob spawned > "..baseName2, 10)
            end
        end)
    end
    for _, mob in ipairs(aliveFolder:GetChildren()) do
        local fullName = mob.Name 
        local baseName = fullName:match("^(.-)%..*$") or fullName 
        if pcall(table.find(lf,baseName2) or table.find(getgenv().moblistt,baseName2) or table.find(functions.mobFarm.selectedMobs,baseName2) and getgenv().mobalert)then
            Rune.PlaySound("rbxassetid://85243953582838")
            NotificationLibrary:SendNotification("Success", "[Mob Notifier]: mob found! | already exist > "..baseName, 10)
        else
            count = count+1
            warn("going")
        end
    end
    warn("finished")
    warn("Hoped")
    if not dontexist and ifnot then
        NotificationLibrary:SendNotification("Error", "[Not Found]: Server-Hoping", 3)
        task.delay(2,function()
            Rune.ServerHop()
        end)
    end
end

function Rune.LoadFairys()
   local tp0 = Rune.TweenTo(1369.93079, 226.980194, -612.139832, 0.787976742, 4.8879027e-08, 0.615705013, 4.83843021e-10, 1, -8.00063091e-08, -0.615705013, 6.33410124e-08, 0.787976742)
   tp0:Wait()
   local tp1 = Rune.TweenTo(10,839.720947265625, 247.71376037597656, -1244.825439453125)
   tp1:Wait()
   local tp2 = Rune.TweenTo(880.40448, 248.975464, -916.14679, -0.994177043, -9.21950516e-09, 0.107758962, -2.141747e-09, 1, 6.57971171e-08, -0.107758962, 6.5183194e-08, -0.994177043)
   tp2:Wait()
   local tp3 = Rune.TweenTo(1567.38525, 162.760025, -1330.1333, 0.47545886, 3.1095599e-08, -0.879737973, 1.59342081e-10, 1, 3.54325493e-08, 0.879737973, -1.6986899e-08, 0.47545886)
   tp3:Wait()
end

return Rune
